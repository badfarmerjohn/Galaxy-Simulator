<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Galaxy Simulator</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>
<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
<h1 align="middle">Final Project: Galaxy Simulator</h1>
<h2 align="middle">Jeromy Lui, Ryan Meyer, Eric Zhang</h2>

<br><br>

<h2 align="middle">Abstract</h2>

In this project, we built a simple galaxy simulator that is visually compelling. Given a certain galaxy image, we are able to initialize particles and physically simulate them. We have both CPU particles, which make up the physically simulated particles in our galaxy, and GPU particles which are used for realistic visual effects which are not part of the physical simulation. In our simulation, the GPU particles are used to mimic real phenomena such as space dust which are present in the simulation but do not affect the dynamics of the N-body system. 

<h2 align="middle">Technical Approach</h2>

<h3 align="middle">Galaxy Image Preprocessing</h3>

The python script takes in a galaxy image and splits it into blocks. Then, it first takes the average pixel value of each block and exports that as a 2D array in some text file. The python script also does the same for the HSV values from each block, exporting those distributions to other text files. Then in the unity code, we sampled particle location and colors from these distrubutions, similar to how we did Monte Carlo integration from previous projects. 

<h2 align="middle">Physics Simulation</h3>
<p>
  The main problem we aimed to tackle with this project was how to simulate real gravitational N-Body dynamics systems while still keeping a high framerate and particle count.
  This became a task to find a healthy balance between performance optimizations and loss of realism. We implemented and compared 3 different systems to simulate the physics of our galaxy.
  To look at the performace of our different systems, we compared the framerate of our simulation to the number of particles being simulated on the CPU.
</p>

<p>
    Our first method to simulate the N-Body physics of our galaxy was to use a 1:1 implementation of real life physics. Essentially, each particle in the system is given a force equal to 
    the sum of all gravitational forces between it and every other particle in the system. This method, while the most physically accurate, is the slowest, as each call to update particle 
    positions takes O(n^2) operations in terms the number of simulated particles.
</p>
<p>
    <img src="naive.png" align="center">
</p>
<p>
    Another physics method we implemented in simulating N-Body dynamics in our galaxy is the circular orbit approximation method. Each particle is given a force equivalent to the total 
    mass of the system being concentrated at the center of mass of the galaxy. This method is constant time per particle update, so the simulation update call is O(n) overall, and allows for 
    the greatest number of particles to be simulated on the CPU. The physical accuracy of this system decreases the further towards the center of the galaxy, as particles closer to the center are given a force as if 
    all other mass was inside of their orbit, even though there are many particles further away in orbit than the centered particles are. As a result, particles which are far away from the galactic center 
    of mass have pretty realistic behavior, while particles in the center may move erratically at times.
</p>
<p>
    <img src="circle.png" align="center">
</p>
<p>
    (DESCRIPTION OF HASHING METHOD)
</p>
<p>
    <img src="hashing.png" align="center">
</p>
<p>
    Here are the results for all three methods put together:
</p>
<p>
    <img src="all3.png" align="center">
</p>
<p>
    The circle approximation performed roughly as well as the spatial hashing approach, and both of these do much better than the naive algorithm as expected. However, since we 
    are conceding some physical accuracy for both methods compared to the naive, it is important to look at the drawbacks of this performance gain. With spatial hashing, we lose the fine 
    details in the direction of forces since particle forces are grouped into buckets rather than each having individual directions. With circular approximation, particles towards the center 
    have less realistic orbiting behavior. These visual errata are small, and are not nearly as noticable as the steep framerate drop that occurs when using the naive force calculations, so the other 
    methods are preferrable for such a large simulation.
</p>

<h2 align="middle">Results</h2>
<iframe width="560" height="315"  src="https://www.youtube.com/embed/JJJzkBQ2yUM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h2 align="middle">References</h2>

<ul>
  <li><b>Unity Game Engine</b>: we used Unity as our development platform as it has a robust rendering and physics pipeline, and has cross-platform compatibility.
    <ul>
      <li><a href="https://docs.unity3d.com/ScriptReference/">Unity API Documentation</a>
      </li>
    </ul>
    <ul>
      <li>
      <a href="https://unity.com/visual-effect-graph">Visual Effects Graph</a>: This is a new tool developed by Unity for its game engine. One of its core features is being able to render and manage a large number of particles.
      </li>
    </ul>
  </li>
  <li>
    <b>
      N-Body Physics
    </b>: we used this resource as a guide to ensure the physical accuracy of our simulation, and for inspiration for our performance optimization methods.
    https://www.cs.cmu.edu/afs/cs/project/pscico-guyb/realworld/www/nbody.html
  </li>
</ul>

<h2 align="middle">Contributions from each team member</h2>

<ul>
  <li>Eric Zhang
    <ul>
      <li>Created CPU and GPU particle managers and higher level functions.
      </li>
    </ul>
    <ul>
      <li>Worked on initializing particle location and color.
      </li>
    </ul>
  </li>
  <li>Ryan Meyer
      <ul>
          <li>Created physics simulator for CPU particles, including the naive and circular force approximation methods.
          </li>
        </ul>
        <ul>
          <li>Calculated physical properties of galaxy to be used by physics simulator (center of mass, initial particle velocities and directions).
          </li>
        </ul>
        <ul>
            <li>Created cubemap skybox for background stars / nebulae.
            </li>
        </ul>
        <ul>
            <li>Ran performance tests and plotted reslts.
            </li>
        </ul>
  </li>
  <li>Jeromy Lui
    <ul>
      <li>Worked on python scripts to split galaxy images into grids and take various distributions based on density and color and input it into text files.
      </li>
    </ul>
     <ul>
      <li>Worked on color correction for both CPU and GPU particles.
      </li>
    </ul>
  </li>
</ul>

</html>